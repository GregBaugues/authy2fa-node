.step(data-title='How it Works', data-file='models/User.js', data-highlight='')
  :markdown
    ### How It Works

    Adding two-factor authentication (2FA) to your web application can help increase the security of your user's data. [Multi-factor authentication](http://en.wikipedia.org/wiki/Multi-factor_authentication) determines the identity of a user by validating one or more of the following "factors":

    * _Knowledge Factors_ (Something a user knows, like a password)
    * _Posession Factors_ (Something a user has, like a mobile phone)
    * _Inheritance Factors_ (Something a user is, like a person with a unique finger print)

    We're about to walk you through a sample application that implements a simple login system with a _knowledge factor_ and a _posession factor_. For the knowledge factor, we will use a standard username/password system. For the possession factor, we will validate that the user has their mobile phone by sending them a one-time passcode in a text message [sent with Authy via Twilio](http://www.authy.com/). Here's how this works at a high level:

    ![2FA High Level](//s3.amazonaws.com/howtodocs/2fa-high-level.png)

    Now it's time to look at some code! We'll begin by understanding the moving parts of this example [Node.js](http://www.nodejs.org) application before diving into the actual implementation of the login flow.

.step(data-title="Our App's Dependencies", data-file='package.json', data-highlight='24-33')
  :markdown
    ### Our App's Dependencies

    As with many Node apps, our application relies on a number of third party libraries to deliver this application. Some of the notable ones are:

    * [`express`](http://expressjs.com) : A light weight web framework for Node.js
    * [`mongoose`](http://mongoosejs.com) : An object-document mapper which makes it easy to create model objects backed by [MongoDB](http://www.mongodb.com/)
    * [`authy`](https://github.com/evilpacket/node-authy) : A high-level helper library for working with the Authy API

    Let's take a look at how our application is configured next.


.step(data-title='Application Configuration', data-file='config.js', data-highlight='')
  :markdown
    ### Application Configuration

    In this file, we pull in configuration parameters for our application that are necessary to run the app. Most are pulled in from system environment variables, which is a helpful way to access sensitive values (like API tokens). This prevents us from accidentally checking them in to source control.

    The configuration parameters we need are:

    * `port` : The HTTP port on which to listen for incoming requests
    * `authyApiKey` : Our key for the authy API - this configuration assumes you will use the "production" token that will actually send out text messages.
    * `mongoUrl` : A connection string for a MongoDB database. `MONGOLAB_URI` is an environment variable that will be set if you deploy this example to [Heroku](http://www.heroku.com) using the button above, as you will be using the free [MongoLab Add-On](https://addons.heroku.com/mongolab).

    If you haven't already, now is the time to [sign up for Authy](https://dashboard.authy.com/signup). Create your first application, naming it whatever you wish. After you create your application, your "production" API key will be visible on your [dashboard](https://dashboard.authy.com):

    ![Authy Dashboard](//s3.amazonaws.com/howtodocs/2fa-authy-dashboard.png)

    Next, let's take a look at the Node.js file we'll use to create and launch our application.


.step(data-title='Bootstrapping The Application', data-file='index.js', data-highlight='')
  :markdown
    ### Bootstrapping The Application

    We use this file to launch the Node process for our application. After pulling in external module dependencies, our bootstrap file has four jobs:

    1. Connect to our MongoDB database using mongoose
    2. Create and configure an Express web application (our entire front end app will be a [Backbone](http://backbonejs.org) application served as static files from the `public` directory)
    3. Create routes to handle all the Ajax requests to our back end application
    4. Finally, create and start an HTTP server that will use our Express app to handle requests

    Now that we understand the basics of how our application is configured and run, let's back up a bit and talk about the [domain model](http://en.wikipedia.org/wiki/Domain_model) for our application.